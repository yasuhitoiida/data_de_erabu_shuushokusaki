### ユーザー機能
###### vue-routerで画面遷移するときのroutes.rb
vue-routerで画面遷移するときは以下の記述がないとリロード時にrailsがno route matchエラーを出す
基本的にはgetリクエストを送ることによって画面遷移をすることはないので、リロードによってgetリクエストが発行される場合はすべてhome#indexの画面をレンダリングさせる　その上でvue-routerによって画面が切り替わる
```
get '*path', to: 'home#index'
```
###### axiosでバリデーションエラーの内容を扱うとき
```
this.$axios.post('users', { user: this.user })
.then(res => {...})
.catch(err => {
  this.errors = err.response.data;
});
```
```
# controller
render json: user.errors.full_messages, status: :unprocessable_entity
```
###### APIのバージョン管理について
APIを外部に公開する必要がないならエンドポイントにバージョンを入れる必要なし

### 評点入力
###### v-forでフォームを複数生成し、それぞれv-modelで配列の要素を入力する
```
<div v-for='(item, index) in itemList' :key='index'>
  <input v-model='itemList[index]' placeholder=''>
</div>
# 第二引数に指定した配列のインデックスを使用し、元の配列の要素を直接参照する
  data() {
    return {
      alternatives: [null, null, null, null, null],
    }
  }
```
###### :valueとv-modelの併用
デフォルトではコンポーネントにある v-model は value をプロパティとして、input をイベントして使いますが、チェックボックスやラジオボタンなどのインプットタイプは value 属性を別の目的で使う事があります。model オプションを使うことでこういった衝突を回避する事ができます。

###### javascriptいろいろ
```
arr = arr1.concat(arr2) // 配列をマージ
let arr = [].concat(arr1) // arrの値が後に変わってもarr1の値は変わらない
let arr = arr1 // これだと変わる

arr = arr1.shift() // arr1から先頭の要素を削除しその要素を新たな配列arrとする
arr.slice(n, m) // arrの先頭からn個、末尾からm個の要素を削除
let a = arr.slice(n,m) // このときaはarrのシャローコピーなのでaの値を変えるとarrも変わる
arr.splice(0, 1, 2) // arrの0番目の要素から数えて1つの要素を削除しそこに2を挿入する
```
- const: ブロックスコープ　再代入不可　再宣言不可　（再代入不可であるが変更されないというわけではない）
- let: ブロックスコープ　再代入可　再宣言不可
- var: 関数スコープ　再代入可　再宣言可

基本的にはconst、使えない場合はletを使う

```
// 文字列str1のm文字目からn文字を切り出し新たな文字列strとする
const str = str1.substr(m,n)
```

### 分析結果
##### vue-chartjs
###### vue-chartjsでグラフを書く
```
% yarn add vue-chartjs chart.js@2.9.4　# バージョン指定しないとエラーになった
```
```
# グラフコンポーネント
import { Bar } from 'vue-chartjs'

export default {
  extends: Bar,
  mounted () {
    this.renderChart(data, options) # dataとoptionsはローカルデータかpropsを使うか、中に直接書く
  }
}
```
###### vue-chartjs全体の設定
```
// どこに書いても良さそう
Chart.defaults.global.defaultFontSize = 18
```
###### chartjs-plugin-datalabelsでグラフ上に値を表示する
```
yarn add chartjs-plugin-datalabels
```
```
import ChartDataLabels from 'chartjs-plugin-datalabels';
// Register the plugin to all charts:
Chart.plugins.register(ChartDataLabels);

export default {
  data() {
    return {
      options: {
        plugins: {
          datalabels: {
            font: {
              weight: 'bold',
              size: 12,
            },
            formatter: (value, ctx) => {
              return value * 100 + '%'
            }
          }
        }
      }
    }
  },
  // Register the plugin to specific charts:
  mounted() {
    this.addPlugin(ChartDataLabels)
  }
}
```
###### resultCalculationメソッドで参照先の引数の値が変わってしまう問題
```
resultCalculation(criImp, altEval) {
  const array = altEval.map(f => {
    const w = criImp.find(g => g.name === f.criterion).weight
    const d = f.data.map(h => {
      const weight = h.weight * w
      return { name: h.name, weight: weight }
    })
    return { criterion: f.criterion, data: d }
  })
  // だめな例1
  // const array = [].concat(altEval)　//concatしても意味無し
  // for(let i = 0; i < altEval.length; i++) {
  //   const w = criImp.find(g => g.name === altEval[i].criterion).weight
  //   const d = array[i].data
  //   for(let j = 0; j < d.length; j++) {
  //     array[i].data[j].weight = altEval[i].data[j].weight * w
  //   }
  // }
  // だめな例2
  // const array = altEval.map(f => {
  //   const w = criImp.find(g => g.name === f.criterion).weight
  //   const d = f.data.map(h => {
  //     h.weight *= w　// 乗算代入はとにかくだめっぽい
  //     return h
  //   })
  //   return { criterion: f.criterion, data: d }
  // })
  return array
 ```
 - JavaScriptにおいてプリミティブ型(配列、ハッシュ以外)は値渡し、オブジェクト型は参照渡し
 - 実際は「参照値」という値を値渡ししている
 ```
 let arr1 = arr2
 ```
  - このときarr1とarr2は同じ値を参照しているが、このあとでarr2が数値になった場合、「その変数がどの値を参照しているか」ということ自体が上書きされてしまい、両者は連動しなくなる
  - 配列やハッシュはミュータブル（変更可）な型　変更は再代入とは別なので参照値が維持される＝参照渡しのような振る舞いが起こる　
 - concatでは配列を値渡しっぽく丸ごとコピーできるが、シャローコピー（1段階の深さのコピー）にしかならないので、多重配列の場合は一部が参照渡しとなってしまう
 ###### 分析結果の取得
 createdフックで取得した値をwatchしたいとき（created時の代入を変更とみなしたくないとき）
 ```
 created() {
   this.selectedCriteria = this.getCriteria
   this.$watch('selectedCriteria', function() {
     // selectedCriteriaが変更されたときに行う処理
   })
 },
 ```

### herokuへのデプロイ
データベースをPostgreSQLに変更
- gem 'pg' をgroup:productionに追加
- gem 'sqlite3'をgroup:development, :testに移動
- database.ymlを編集
```
production:
    <<: *default
    adapter: postgresql
    encoding: unicode
    pool: 5
```

vuetifyとbootstrapを併用するとき
- packs/hello_vue.jsの内容をすべてpacks/application.jsに移動
- application.html.erbのstylesheet_link_tagをstylesheet_pack_tagに変更
- packs/src/application.scssを作成し、
```@import '~bootstrap/dist/css/bootstrap'```を記述

### 一対多の関係にある複数のリソースを一括登録する
ポイント
- 複数のリソースをまとめたクラスを作り、ActiveModelを用いてモデルの機能を与える
- そのクラスにActiveModel::Attributesでone側のクラスの属性とmany側のクラス名を属性として与える many側のインスタンスの配列はそこに格納される
- ストロングパラメータにおいて、one側のパラメータに加えてmany側のクラス名をパラメータとして与え、その属性を配列として渡す
- 複数のリソースの登録にはaccepts_nested_attributes_forが使えるが、非推奨である

```
#AnalysesController
def create
  analysis = AnalysisObject.new(analysis_params)

  if analysis.save
    render json: analysis
  else
    render json: analysis.errors.full_messages, status: :unprocessable_entity
  end
end

private

def analysis_params
  params.require(:analysis).permit(criterion_importance: [:name, :weight], alternative_result: [:name, :total, multipledWeight:[:criterion, :value]])
end
```
```
#models/analysis_object.rb
class AnalysisObject < ApplicationController
  include ActiveModel::Model
  include ActiveModel::Attributes

  attribute :criterion_importance
  attribute :alternative_result

  def save
    analysis = @@current_user.analyses.build
    analysis.save

    self.criterion_importance.each do |cri|
      analysis.criterion_importances.create(criterion_name: cri[:name], weight: cri[:weight])
    end

    self.alternative_result.each do |alt|
      alternative = analysis.alternative_results.create(alternative_name: alt[:name], total: alt[:total])
      alt[:multipledWeight].each do |arr|
        alternative.multipled_weights.create(criterion_name: arr[:criterion], value: arr[:value])
      end
    end
  end
end
```

###### ActiveModelでできないこと
- インスタンス変数はクラスをまたいだ呼び出しができない=コントローラで定義した@current_userなどの値が使えない
- クラス変数は継承することで子クラスでも呼び出しができるようになる=コントローラクラスを継承すれば@@current_userが使える
- リクエストを取得するrequestオブジェクトは、コントローラのアクションを経由すると使えない

### AWSへのデプロイ
ハマりポイント
- SQLite3のバージョン
- pg_hba.confの認証の内容
- アセットのコンパイル
```
$ rails webpacker:install
$ rails webpacker:compile
ただし先にcapistrano走らせちゃえば問題なし
```
```
# webpacker.yml
production:
    extract_css: false
```
herokuデプロイ対策で空にしたhello_vueはもとに戻す。

### ログ設定
ログレベル
0. :debug
1. :info
2. :warn
3. :error
4. :fatal

```
# config/environments/production.rb

# ログレベルをinfoに上げる
config.log_level = :info

# ログローテート
config.logger = Logger.new("log/production.log", 5, 10 * 1024 * 1024) # サイズでローテート
config.logger = Logger.new("log/production.log", 'daily') # 日数でローテート
```

### Capistrano
NoMethodError: Cannot load database configuration: が出るとき
- リモートのmaster.keyはshared/configにつくる
- ```set :linked_files, fetch(:linked_files, []).push("config/master.key")```をdeploy.rbに記述

ログはshared/log内のファイルに出力される

### HTTPS接続
AWS
- ロードバランサーのリスナー: 80, 443
- ターゲットグループ: 80
- EC2のセキュリティグループ: 80

Nginx
- server: 80

Rails
- config.force_ssl = false

手順
- 1つ目のインスタンスを作成し、すべてのインストールと設定を済ます
- AMIを作成しそれをもとに2つ目のインスタンスを作成する
- ロードバランサーを設置
- デプロイ

### Vuetify豆知識
v-checkboxはバインドしてる配列内に選択済みの要素が重複してもチェックを外せばすべて除去できる
